# This file is released under terms of BSD license
# See LICENSE file for more information

function claw_f_print_help()
{
cat <<EOF
usage: $1 <OPTIONS> <INPUTFILE> ...

CLAW Fortran compiler options:

   -o <file>                  : place the output into <file>.
   -I <dir>                   : add the directory dir to the list of directories to be searched for header files.
   -J <dir>                   : specify where to put .mod and .xmod files for compiled modules.
   -D <dir>                   : specify output directory for transformed files
   -t=,--target=<target>      : specify the type of accelerator directive language for code generation.
   --target-list              : list the available type of accelerator directive language supported.
   -d=,--directive=<dir-lang> : specify the type of accelerator directive language for code generation.
   --directive-list           : list the available type of accelerator directive language supported.
   --config=<config_file>     : specify a different configuration for the translator.
   --show-config              : list the current configuration information. If used with --config, list the information from the specific configuration.
   -v,--verbose               : print processing status.
   --version                  : print version.
   -h,--help                  : print usage.
   --show-env                 : show environment variables.
   --no-dep                   : don't generate .mod or .xmod file for dependencies.
   -f,--force                 : force the translation of files without directives.
   --debug                    : save intermediate files in __omni_tmp__.
   --stop-pp                  : save intermediate files and stop after preprocess.
   --stop-dependencies        : save intermediate files and stop after dependencies resolution.
   --stop-frontend            : save intermediate files and stop after frontend.
   --stop-translator          : save intermediate files and stop after translator.

Decompiler options:
   -w <integer>               : Set the number of columns for the output Fortran file (default: 80).
   -l                         : Add preprocessor line directives in the output Fortran file.

Process Options

   --Wp[option] : Add preprocessor option.
   --Wf[option] : Add frontend option.
   --Wx[option] : Add Xcode translator option.
   --Wb[option] : Add backend option.
EOF
}

function claw_f_show_env()
{
  CONF_FILE=$OM_CX2X_DRIVER_CONF_DIR/claw_f.conf
  if [ -f $CONF_FILE ]; then
    for val in `sed '/^[[:space:]]*$/d' ${CONF_FILE} | grep -v '^#' | awk -F= '{print $1}'`
    do
      echo -n ${val}=\"
      eval echo -n \"\$$val\"
      echo \"
    done
  else
    omni_error_exit "$CONF_FILE not exist."
  fi
}

function get_target()
{
  clawfc --show-env | grep TARGET | sed 's/TARGET=//' | sed "s/\"//g"
}

function claw_f_set_parameters()
{
  while [ -n "$1" ]; do
    case "$1" in
      *.f90|*.f|*.F90|*.F)
        f_files+=("$1");;
      *.a)
        archive_files+=("$1");;
      *.o)
        obj_files+=("$1");;
      -o)
        shift; output_file=("$1");;
      -D)
        shift; output_dir=("$1");;
      -J)
        shift;
        module_dir=("${1#-J}")
        if [[ $module_dir == \/* ]]
        then
          module_opt+=("-M${module_dir[0]}")
        else
          current_dir=$(pwd)
          module_opt+=("-M$current_dir/${module_dir[0]}")
        fi
        #target=`get_target`
        #if [ "$target" = "Kcomputer-linux-gnu" -o "$target" = "FX10-linux-gnu" ]
        #then
        #  other_args+=("${OMNI_MODINC}${module_dir}")
        #else
        #  other_args+=("${OMNI_MODINC}" "${module_dir}")
        #fi;;
        ;;
      -J?*)
        module_dir=("${1#-J}")
        module_opt+=("-M${module_dir[0]}")
        #target=`get_target`
        #if [ "$target" = "Kcomputer-linux-gnu" -o "$target" = "FX10-linux-gnu" ]
        #then
        #  other_args+=("${OMNI_MODINC}${module_dir}")
        #else
        #  other_args+=("${OMNI_MODINC}" "${module_dir}")
        #fi;;
        ;;
      -I)
        shift;
        include_opt+=("-I$1")
        other_args+=("-I$1")
        module_dir=("${1#-I}")
        trans_module_opt+=("-M${module_dir[0]}");;
      -I?*)
        include_opt+=("$1")
        other_args+=("$1")
        module_dir=("${1#-I}")
        trans_module_opt+=("-M${module_dir[0]}");;
#      -c) # Option disable for clawfc
#        ENABLE_LINKER=false;;
      -E)
        ONLY_PP=true;;
      -cpp)
        ENABLE_CPP=true;;
      -v|--verbose)
        VERBOSE=true;;
      --version)
        claw_f_print_version; exit 0;;
      -h|--help)
        claw_f_print_help `basename $0`; exit 0;;
      --show-env)
        claw_f_show_env; exit 0;;
      -f|--force)
        FORCE_TRANSLATION=true;;
      --no-dep)
        RESOLVE_DEPENDENCIES=false;;
      --tmp)
        OUTPUT_TEMPORAL=true;;
      --dry)
        DRY_RUN=true;;
      --debug)
        ENABLE_DEBUG=true;;
      --stop-pp)
        VERBOSE=true; STOP_PP=true;;
      --stop-frontend)
        VERBOSE=true; STOP_FRONTEND=true;;
      --stop-dependencies)
        VERBOSE=true; STOP_DEPENDENCIES=true;;
      --stop-translator)
        VERBOSE=true; STOP_TRANSLATOR=true;;
      --stop-backend)
        VERBOSE=true; STOP_BACKEND=true;;
      --stop-compile)
        VERBOSE=true; STOP_COMPILE=true;;
      --Wp*)
        pp_add_opt+=("${1#--Wp}");;
      --Wf*)
        frontend_add_opt+=("${1#--Wf}");;
      --Wx*)
        xcode_translator_add_opt+=("${1#--Wx}");;
      --Wn*)
        native_add_opt+=("${1#--Wn}");;
      --Wb*)
        backend_add_opt+=("${1#--Wb}");;
      --Wl*)
        linker_add_opt+=("${1#--Wl}");;
      --target-list)
        LIST_TARGET=true;;
      --show-config)
        SHOW_CONFIG=true;;
      -t=*)
        TARGET=true;
        target_opt+=("${1#-t=}");;
      --target=*)
        TARGET=true;
        target_opt+=("${1#--target=}");;
      --directive-list)
        LIST_DIRECTIVE=true;;
      -d=*)
        DIRECTIVE=true;
        directive_opt+=("${1#-d=}");;
      --directive=*)
        DIRECTIVE=true;
        directive_opt+=("${1#--directive=}");;
      --config=*)
        CONFIG=true;
        config_opt+=("${1#--config=}");;
      -w)
        MAX_COLUMN=true;
        shift; max_columns=("$1");;
      -l)
        LINE_DIRECTIVE=true;;
#	    --openmp|-omp)
#		ENABLE_OPENMP=true;;
#	    --xcalableacc|-xacc)
#		ENABLE_XACC=true;;
#	    --scalasca-all)
#		ENABLE_SCALASCA_ALL=true;;
#	    --scalasca)
#		ENABLE_SCALASCA=true;;
#	    --tlog-all)
#		ENABLE_TLOG_ALL=true;;
#	    --tlog)
#		ENABLE_TLOG=true;;
      *)
        other_args+=("$1");;
    esac
    shift
  done

  # Add automatically preprocessor macro for corresponding target
  pp_add_opt+=("-D_CLAW")
  if [ "${directive_opt[0]}" == "openacc" ]
  then
    pp_add_opt+=("-D_OPENACC")
  elif [ "${directive_opt[0]}" == "openmp" ]
  then
    pp_add_opt+=("-D_OPENMP")
  fi

  if test $OUTPUT_TEMPORAL = true -a $DRY_RUN = true; then
    omni_error_exit "cannot use both --tmp and --dry options at the same time."
  fi
}

function claw_f_print_version()
{
  echo "CLAW Fortran compiler @CLAWFC_VERSION@"
}

# Process dependencies file trough the frontend
# $1 must be set to the file to process dependencies
function claw_f_process_dependencies()
{
  dependencies=()
  module_regex="^[[:space:]]*(USE|use)[[:space:]]*([^,]*)"
  while IFS= read -r line
  do
    if [[ $line =~ $module_regex ]]
    then
      module_name="${BASH_REMATCH[2]}"
      dependencies+=("$module_name")
    fi
  done <$1

  echo ${dependencies[@]}

  # Get the directory and use it to look in the same for dependencies
  moddirname=$(dirname $2)

  for dep in "${dependencies[@]}"
  do
    module_name=${dep// }
    module_name=${module_name%% }
    module_file=""
    if [[ -f $module_name.f90 ]]
    then
      module_file="$module_name.f90"
    elif [[ -f $module_name.F90 ]]
    then
      module_file="$module_name.F90"
    elif [[ -f $module_name.f ]]
    then
      module_file="$module_name.f"
    elif [[ -f $module_name.F ]]
    then
      module_file="$module_name.F"
    # Dependencies not found in the current dir. Try to check in the same dir.
    elif [[ -f "$moddirname/$module_name.f90" ]]
    then
      module_file="$moddirname/$module_name.f90"
    elif [[ -f $moddirname/$module_name.F90 ]]
    then
      module_file="$moddirname/$module_name.F90"
    elif [[ -f $moddirname/$module_name.f ]]
    then
      module_file="$moddirname/$module_name.f"
    elif [[ -f $moddirname/$module_name.F ]]
    then
      module_file="$module_name.F"
    else
      echo "Error: cannot find module file $dep"
      exit 1;
    fi

    module_xmod_file="$module_name.xmod"
    if [[ -f $module_xmod_file && $module_xmod_file -nt $module_file ]]
    then
      continue # Skip when .xmod file already exists
    fi

    ### Preprocess file ###
    FILE=$module_file
    FILE_NAME=`omni_f_norm_file_name "${FILE}"`     # ./hoge/fuga.F -> hoge_2f_fuga_2f_a
    EXT=${file##*.}
    local FILE_PP=${TEMP_DIR}/"${FILE_NAME}".${EXT}

    # When ">" or ">>" is used, please use "omni_exec_echo" and "omni_exec_run" instead of "omni_exec".
    omni_exec_echo $OMNI_FPP_CMD "${include_opt[@]}" "${pp_add_opt[@]}" $OMNI_FPP_OPT "${other_args[@]}" "${FILE}" ">" "${FILE_PP}"
    omni_exec_run  $OMNI_FPP_CMD "${include_opt[@]}" "${pp_add_opt[@]}" $OMNI_FPP_OPT "${other_args[@]}" "${FILE}" > "${FILE_PP}"

    # Recurse to get dependencies in the right order
    claw_f_process_dependencies $FILE_PP $FILE

    FILE_IN_X=${TEMP_DIR}/"dummy.xml"

    # Pass the module in the front-end to get the .xmod file
    omni_exec $OMNI_F2X_CMD "${include_opt[@]}" "${module_opt[@]}" "${frontend_add_opt[@]}" $OMNI_F2X_OPT "${FILE_PP}" -o "${FILE_IN_X}"

    rm -f $FILE_IN_X

  done
}

# Apply the ignore directive. All lines between `!$claw ignore` and
# `!$claw end ignore` are prefixed with the `!$claw ignore` prefix.
# Parameters:
# $1 : input file path edited in place
function applyIgnore()
{
  # Retrieve the ignore start directives in the file
  local startarray=( $(grep -n "\s*\!\$claw ignore" $1 | cut -f1 -d:) )
  # Retrieve the ignore end directives in the file
  local endarray=( $(grep -n "\s*\!\$claw end ignore" $1 | cut -f1 -d:) )

  # Check that we have the same number of start and end directives
  local startlen=${#startarray[*]}
  local endlen=${#endarray[*]}
  if [ "${#startlen[@]}" -ne "${#endlen[@]}" ]; then
    echo "Missing directives"
    exit 1
  fi

  for (( i=0; i<=$(( $startlen -1 )); i++ ))
  do
    local sedstart=$((${startarray[$i]} + 1)) # Compute the start line
    local sedend=$((${endarray[$i]} - 1))     # Compute the end line

    if [ "$sedstart" -gt "$sedend" ]
    then
      echo "claw-error: inverted start-end in ignore directive. ($sedstart:$sedend)"
      exit 1
    fi

    # Insert directive as prefix of each line in the block
    sed -i.bak -e "$sedstart,$sedend s/^/!\$claw ignore/" $1

    # Hide continuation line in the ignored block. If we keep them, the
    # front-end will merge the lines together.
    sed -i.bak -e "$sedstart,$sedend s/&/__CLAWAMP__/" $1
  done
}

# Revert the lines saved by the ignore directive
# All lines starting with !$claw ignore will be modified. The directive is
# removed and the text after is kept.
# $1 : file path
function revertIgnore()
{
  sed -i.bak -e "s/\!\$claw ignore//" $1
  sed -i.bak -e "s/\!\$claw end ignore//" $1

  # Revert the hidden continuation line.
  sed -i.bak -e "s/__CLAWAMP__/\&/" $1
  rm -f $1.bak
}

# Apply the verbatim directive
# Remove all the !$claw verbatim from lines
function applyVerbatim()
{
  sed -i.bak -e "s/\!\$claw verbatim //" $1
}
